import numpy as np
import cv2
import PIL.Image as Im
import PIL
from PIL import EpsImagePlugin
EpsImagePlugin.gs_windows_binary =r'C:\Program Files\LyX 2.3\ghostscript\bin\gswin64.exe' 
import matplotlib.pyplot as pl

N=12
Ns=N**2
F=1#20#25#7#12
gamma=0.98
g=1./gamma
alpha=10.
bet=10./alpha
#itst=0.002
nz=0.#0.12#0.27
uhas=0
Na=9
food=np.zeros((N,N),int)
#food[0,0]=F-1
#food[N-1,N-1]=F-1

fl=1#4#N//2-2
food[fl,1]=F#-1
#food[N-1-fl,1]=F#-1

#food+=1
form=np.zeros((2,N,N),int)
#form+=1

form[0,0:3,0:3]=1
#form[0,N-3:N,0:3]=1
#form[0,3:N-3,1]=1
form[0,3:N,1]=1

form[1,N-1,N-1]=1

food=food*form[0]

food=form[0]
print("food",food)

Form=np.ones((F,Ns))
FormQ=np.ones((F,Ns))

for i in range(Ns):
        Form[:,i]=form[0,i//N,i%N]		
        FormQ[:,i]=form[0,i//N,i%N]

def stopos(s):
    f=s//N**4
    s=s%N**4
    s1=s//(N**2)
    s2=s%(N**2)
    a=np.zeros(5, int)
    a[0]=f
    a[1]=s1//N
    a[2]=s1%N
    a[3]=s2//N
    a[4]=s2%N
    return a

def postos(a):
    s=(N*a[1]+a[2])*N**2+(N*a[3]+a[4])+a[0]*N**4
    return s

def ifa(s,a,ind):
	pos=stopos(s)
	pos[ind]+=a//3-1
	pos[ind+1]+=a%3-1
	w=0
	if (pos[ind]<N) and (pos[ind]>=0) and (pos[ind+1]<N) and (pos[ind+1]>=0):
		if (form[(ind-1)//2,pos[ind],pos[ind+1]]==1): 
			w=1
	return w


def nexts(s,a):
    pos=stopos(s)
    pos0=np.zeros((5), int)
    for i in range(5):
        pos0[i]=pos[i]
    lists=[]
    listp=[]
    if (pos[0]==-1): #or ((pos[1]==pos[3]) and (pos[2]==pos[4])):
        pos[0]=-1
    else:
        pos[0]=pos[0]-1+food[pos[1],pos[2]]
        if (pos[0]>=F):
            pos[0]=F-1
        if (pos[0]>=0):
            pos[1]=(pos[1]+a//3-1)#%N
            pos[2]=(pos[2]+a%3-1)#%N
            if pos[1]<0:
                pos[1]=0
            if pos[1]>N-1:
                pos[1]=N-1
            if pos[2]<0:
                pos[2]=0
            if pos[2]>N-1:
                pos[2]=N-1
    pos1=np.zeros((5), int)
    for i in range(5):
        pos1[i]=pos[i]
    for a2 in range(1):#9
        #if (ifa(s,a2,3)==1):
        #   pos1[3]=(pos[3]+a2//3-1)#%N
        #   pos1[4]=(pos[4]+a2%3-1)#%N
           lists.append(postos(pos1))
           listp.append(1.)#wp[pos0[1]*N+pos0[2],pos0[3]*N+pos0[4],pos1[3]*N+pos1[4] ])
    return lists,listp

def W01(pos,pos1):
    w=0
    if (pos[0]==0) and (pos!=pos1):
        w=0
    else:
        if (pos[0]-1+food[pos[1],pos[2]]==pos1[0]) and (abs(pos[1]-pos1[1])<=1) and (abs(pos[2]-pos1[2])<=1):
            w=1
    return w

def W2(pos,pos1):
    w=0
    if (abs(pos[1]-pos1[1])<2) and (abs(pos[2]-pos1[2])<2):
            w=1
    return w

def Wnum(pos,pos1):
    w=0
    if (abs(pos//N-pos1//N)<2) and (abs(pos%N-pos1%N)<2) and (form[0,pos1//N,pos1%N]==1) and (form[0,pos//N,pos%N]==1):
            w=1
    return w

def Wnum2(pos,pos1):
    w=0
    if (abs(pos//N-pos1//N)<2) and (abs(pos%N-pos1%N)<2) and (form[1,pos1//N,pos1%N]==1) and (form[1,pos//N,pos%N]==1):
            w=1
    return w

beta=2.
miop=0
def Wp(pos1,pos2):
	wp=np.zeros((3,3))
	l=np.sqrt((pos1//N-pos2//N)**2+(pos1%N-pos2%N)**2)
	if (l>0):
		for i in range(3):
			for j in range(3):
				wp[i,j]=(i-1)*(pos1//N-pos2//N)+(j-1)*(pos1%N-pos2%N)
				if (abs(i-1)==1) and (abs(j-1)==1):
					wp[i,j]*=1./np.sqrt(2)
		wp*=1./l#*1./l#**2
		if (miop==1):
			if (l>1):
				wp*=1./l
	#wp+=(1.-sum(wp))/9.
	#print("wp",wp)
	wpmax=np.amax(wp)
	wp-=wpmax
	wpsum=0
	for i in range(3):
		for j in range(3):
			wp[i,j]=np.exp(beta*wp[i,j])
			wpsum+=wp[i,j]
	#wpsum=sum(wp)
	wp*=1./wpsum
	print("wp_exp",wp)
	return wp
        
        
#z=np.ones(F*N**4)*1.
zpos=np.ones((F,N*N))*1.#,N*N
zpos1=np.ones((F,N*N))*1.#,N*N
zposfin=np.ones((F,N*N))*1.#,N*N
lnz=np.zeros((N*N))*1.#,N*N
v=np.zeros((F,N*N))*1.#,N*N
dv=np.zeros((F,N*N))*1.#,N*N
vfin=np.zeros((F,N*N))*1.#,N*N
zaf=np.zeros((F,N*N))*1.#,N*N
Q1=np.ones((F,N*N))*1.#,N*N
Q=np.ones((F,N*N))*1.#,N*N
za=np.zeros((N*N))
zap=np.zeros((N*N))
w1=np.zeros((N**2,N**2))
w2=np.zeros((N**2,N**2))
w01=np.zeros((N**2,N**2))
w=np.zeros((N**4,N**4))
for i in range(N**2):
    for j in range(N**2):
        w1[i,j]=Wnum(i,j)
        w2[i,j]=Wnum2(i,j)
        w01[i,j]=Wnum(i,j)
    w01[i,i]=0
        
#print("w1",w1)

wp0=np.zeros((N**2,N**2))
for j in range(N**2):
	k=0
	for i1 in range(3):
		for j1 in range(3):
			if (j//N+i1-1>=0) and (j//N+i1-1<N) and (j%N+j1-1>=0) and (j%N+j1-1<N):
				wp0[j,(j//N+i1-1)*N+j%N+j1-1]=1.
				k+=1
	wp0[j]*=1./k

wp=np.zeros((N**2,N**2,N**2))
for i in range(N**2):
	for j in range(N**2):
		if form[1,j//N,j%N]==1:
			wploc=Wp(i,j)
			sumloc=0.
			for i1 in range(3):
				for j1 in range(3):
					i11=j//N+i1-1
					j11=j%N+j1-1
					if (j11>=0) and (j11<N) and (i11>=0) and (i11<N):
						wploc[i1,j1]*=w2[j,i11*N+j11]
						sumloc+=wploc[i1,j1]
			for i1 in range(3):
				for j1 in range(3):
					i11=j//N+i1-1
					j11=j%N+j1-1
					if (j11>=0) and (j11<N) and (i11>=0) and (i11<N):
						wp[i,j,i11*N+j11]=wploc[i1,j1]/sumloc
        

print("wp0",wp0)
wp0=wp[0]
print("wp[0]",wp[0])


dist=np.ones((N**2,N**2),int)
dist*=-1
for i in range(N**2):
    for j in range(N**2):
        if (form[0,i//N,i%N]==1) and (form[1,j//N,j%N]==1) and (form[1,i//N,i%N]==1):
            if (abs(i//N-j//N)<=1) and (abs(i%N-j%N)<=1):
                dist[i,j]=1
            if (i==j):
                dist[i,j] = 0

for k in range(N**2):
    for i in range(N**2):
        for j in range(N**2):
                if  (dist[i,k]>=0 and dist[k,j]>=0) and ( dist[i,j]<0  or dist[i,j] > dist[i,k] + dist[k,j]): 
                    dist[i,j] = dist[i,k] + dist[k,j]
#print("dist")
#for i in range(N**2):
#    print(dist[i])
dhist=np.zeros(np.amax(dist)+2,int)

hwp=np.zeros((N**2,N**2))
lnwp=np.zeros((N**2,N**2))
print("hwp")
for i in range(N**2):
	for j in range(N**2):
		for k in range(N**2):
			if (wp[i,j,k]>0):
				lnwp[j,k]=np.log(wp[i,j,k])
			else:
				lnwp[j,k]=-100.
		hwp[i,j]=-np.dot(wp[i,j],lnwp[j])
	print(hwp[i])


uload=1
usafe=1
uvideo=0
urecload=0
T=1000
pref="hs_ziter_zformedW_nofood1room1bridge_fulltank "#"hs_ziter_zformedW_2rooms1bridge_fulltank "  
postf="N"+str(N)+"F"+str(F)+"fl"+str(fl)+"beta"+str(beta)+"miop"+str(miop)+"nz"+str(nz)+"gamma"+str(gamma)+"alpha"+str(alpha)+"bet"+str(bet)
pref+=postf+"has"+str(uhas)+"T"+str(T)
ledy=np.zeros(T)
dledy=np.zeros(T)
mady=np.zeros(T)
dmady=np.zeros(T)
Qmady=np.zeros(T)
if (uload==0):

    if alpha>bet:
            normpot=(alpha/bet-1.)
            #zpos[F-1,fl*N+1]=1.#fix one finite V
    else:
            #iterpot=bet/(bet+alpha)
            normpot=0.
    iterpot=1./(1.+alpha/bet+normpot)
    #fc=np.ones((F,N**2))
    #for i in range(N**2):
    #        fc[F-1,i]=food[i//N,i%N]

    print("checkQ0")
    checkQ=np.zeros((F,Ns))
    for f in range(F):
        for i in range(Ns):
            f2=min(F-1,f-1+food[i//N,i%N])
            checkQ[f,i]=zpos[f,i]*np.dot(w1[i],Q[f])
            if f2>=0:
                checkQ[f,i]+=-(Q1[f2,i]/zpos[f,i])**(alpha/bet)
        print(checkQ[f])
    #pl.plot(ledy)
    #pl.show()
    print("zpos0",zpos)
    for t in range(T):
        #zaf=np.exp(v*1./alpha)
        zaf[:]=zpos[:]
        #print("zaf",zaf)
        Q1=np.dot(zaf,w1)
        print("Q1")
        for f in range(F):
            print(Q1[f])
        Q=np.zeros((F,N*N))
        for i in range(N**2):
            for f in range(F):
                    f00=f+1-food[i//N,i%N]
                    u=1
                    if (f==F-1):
                        f01=f
                    else:
                        f01=f00
                    for f0 in range(f00,f01+1):
                        if (f0>=0) and (f0<F) and (Form[f0,i]==1):
                            u*=0
                    if u==1:
                        FormQ[f,i]=0
                    else:
                        FormQ[f,i]=1
        print("FormQ",FormQ)
        for i in range(N**2):
            for f in range(F):
                if form[0,i//N,i%N]==1:
                    if Q1[f,i]>0:
                        Q[f,i]=Q1[f,i]**(alpha/bet-1)
                    f00=f+1-food[i//N,i%N]
                    u=1
                    if (f==F-1):
                        f01=f
                    else:
                        f01=f00
                    m=0.
                    for f0 in range(f00,f01+1):
                        if (f0>=0) and (f0<F) and (Form[f0,i]!=0):
                            if (np.dot(w1[i],FormQ[f0])>0):
                                u*=0
                                if (Q[f,i]>0):
                                    m+=zpos[f0,i]**(-alpha/bet)#Q[f,i]*=zpos[f0,i]**(-alpha/bet)
                            else:
                                #Q[f,i]*=0.
                                Form[f0,i]=0
                                zpos[f0,i]=0.
                        #else:
                            #Q[f,i]*=0. 
                    if u==1:
                        Q[f,i]*=0.
                    else:
                        Q[f,i]*=m
        #print("Q",Q)                   

        print("t,Form",t)
        #for f in range(F):
        #    print(zpos[f])#v
        for f in range(F):
            print(Form[f])
        for i in range(N**2):
            if form[0,i//N,i%N]==1:
                for f in range(F):
                    if Form[f,i]==1:
                        f2=min(F-1,f-1+food[i//N,i%N])
                        if f2>=0:
                            if np.dot(w1[i],Q[f])>0:
                                zpos[f,i]=Q1[f2,i]**(alpha/bet)/np.dot(w1[i],Q[f])  *zaf[f,i]**normpot      #Q1=np.dot(zaf[f2,:],w1[i])
                                zpos[f,i]=zpos[f,i]  **iterpot#**(bet/(bet+alpha))
                            else:
                                zpos[f,i]=0.#10.**10
                        else: 
                            zpos[f,i]=0.
                            #zpos[f,i]=zaf[f,i]**(alpha/bet)/(np.dot(w1[i],Q[f])+zaf[f,i])
                            #zpos[f,i]=zpos[f,i]**(bet/(bet+alpha))

        #if alpha>bet:
        #    zpos[F-1,fl*N+1]=1.#fix one finite V

        #print("zaf*w1",np.dot(zaf,w1))
        #norm=np.prod(zpos)**(-1./sum(sum(Form)))
        norm=1.
        normc=0
        for i in range(N**2):
            for f in range(F):
                if (Form[f,i]==1) and (zpos[f,i]>0):#form[0,i//N,i%N]==1:
                    norm*=zpos[f,i]
                    normc+=1
        print("prod_nonorm",norm,normc)
        #norm=norm**(-1./normc)
        #for i in range(N**2):
        #    for f in range(F):
        #        if (Form[f,i]==1) and (zpos[f,i]>0):#form[0,i//N,i%N]==1:
        #            zpos[f,i]*=norm
        #print("check_norm",sum(sum(v)))
        #print("check_norm",np.prod(zpos))
        ledy[t]=zpos[F-1,0]
        mady[t]=np.amax(zpos*Form)
        checkQ=np.zeros((F,Ns))
        for f in range(F):
            for i in range(Ns):
                if zpos[f,i]>0:
                    f2=min(F-1,f-1+food[i//N,i%N])
                    checkQ[f,i]=zpos[f,i]*np.dot(w1[i],Q[f])
                    if f2>=0:
                        checkQ[f,i]+=-(Q1[f2,i]/zpos[f,i])**(alpha/bet)
                    checkQ[f,i]=abs(checkQ[f,i])

        #checkQ[F-1,fl*N+1]=0.
        Qmady[t]=np.amax(checkQ*FormQ)

        print("t,z",t)
        for f in range(F):
            print(zpos[f])
        print("t,Q",t)
        for f in range(F):
            print(Q[f])

        if t==T-2:
            #print("dv/v")
            for f in range(F):
                #vfin[f]=v[f]
                #print(dv[f]/v[f])
                zposfin[f]=zpos[f]
    #zposfin=np.exp(vfin*1./alpha)
    #zpos=np.exp(v*1./alpha)
    print("zposfin")
    for f in range(F):
        print("f ",f)
        print(zposfin[f])
        #for i in range(N**2):
        #    print(zposfin[f,i])
    print("zposfin-zpos")
    for f in range(F):
        print("f ",f)
        print(zposfin[f]-zpos[f])
    print("zposfin/zpos")
    for f in range(F):
        print("f ",f)
        print(zposfin[f]/zpos[f])
    print("checkQ")
    checkQ=np.zeros((F,Ns))
    for f in range(F):
        for i in range(Ns):
            f2=min(F-1,f-1+food[i//N,i%N])
            checkQ[f,i]=zpos[f,i]*np.dot(w1[i],Q[f])
            if f2>=0:
                checkQ[f,i]+=-(Q1[f2,i]/zpos[f,i])**(alpha/bet)
        print(checkQ[f])


    if (usafe==1):
        file = open(pref, "wb")
        np.save(file, zposfin)
        file.close
else:
    file = open(pref, "rb")
    zposfin = np.load(file)
    file.close
    print("zposfin")#,zposfin)
    for f in range(F):
        print(zposfin[f])

ps=np.zeros((F,Ns))
ps2=np.zeros((F,Ns))
pas=np.zeros((F,Ns,Ns))
F2=np.zeros((F,Ns),int)
Z=0.
Q1=np.dot(zposfin,w1)
for f in range(F):
            for i in range(Ns):
                if zposfin[f,i]>0:
                    f2=min(F-1,f-1+food[i//N,i%N])
                    if f2>=0:
                        F2[f,i]=f2
                        for j in range(Ns):
                            pas[f,i,j]=w1[i,j]*zposfin[f2,j]/Q1[f2,i]
                        ps[f,i]=(Q1[f2,i]/zposfin[f,i])**(alpha/bet)
                    else:
                        ps[f,i]=1.
                        pas[f,i,i]=1.
                else:
                        ps[f,i]=1.
                        pas[f,i,i]=1.
                Z+=ps[f,i]

print("Z",Z)
ps*=1./Z
for f in range(F):
            for i in range(Ns):
                for j in range(Ns):
                    ps2[F2[f,i],j]+=pas[f,i,j]*ps[f,i]
checkps=ps-ps2
print("checkps",checkps)
print("max_checkps",np.amax(abs(checkps)))
print("max_ps",np.amax(ps))


pl.plot(ledy) 
pl.show()   
pl.plot(mady) 
pl.show()  
pl.plot(Qmady) 
pl.show()  
     
pref="ncop1_"+pref 

#spos=np.array([F-1,0,1,N-1,N-1])
spos=np.array([F-1,N//2,1,N-1,N-1])
u=0
for k in range(0): #10
	spos[1]=int(N*np.random.rand())
	spos[2]=int(N*np.random.rand())
	spos[3]=int(N*np.random.rand())
	spos[4]=int(N*np.random.rand())
	if (form[0,spos[1],spos[2]]==1) and (form[1,spos[3],spos[4]]==1):
		u=1
		break
if u==0:
	spos=np.array([F-1,fl,1,N-1,N-1])#[F-1,N//2,1,N-1,N-1]
s=postos(spos)
spos0=stopos(s)
dhist[dist[spos[1]*N+spos[2],spos[3]*N+spos[4]]]+=1

pa=np.zeros(Na)*1.
print("s",stopos(s))

import turtle
turtle.ht()
scr = turtle.getscreen()
t0 = turtle.Turtle()
t0.speed(0) #10
dx=80#120#
t0.penup()
t0.ht()

screen = turtle.Screen()
screen.register_shape("cat2.gif")
screen.register_shape("mouse_active3.gif")
screen.register_shape("mouse_quiet3.gif")
screen.register_shape("cheese.gif")
screen.register_shape("cheese-white.gif")
#screen.setworldcoordinates(0,0,10,10)
x0=-400
y0=-425
mrg=0.#int(dx/4.)


#for i in range(N):
#	for j in range(N):
#		if form[0,i,j]==1:
#			t1.penup()
#			t1.goto(i*dx,j*dx)
#			t1.pendown()
#			t1.goto(i*dx,(j+1)*dx)
#			t1.goto((i+1)*dx,(j+1)*dx)
#			t1.goto((i+1)*dx,j*dx)
#			t1.goto(i*dx,j*dx)

#for i in range(N+1):
#        t1.penup()
#        t1.goto(i*dx,0) #N//2 *dx)
#        t1.pendown()
#        t1.goto(i*dx,N*dx)
#for i in range(N+1):
#        t1.penup()
#        t1.goto(0,i*dx) #N//2 *dx)
#        t1.pendown()
#        t1.goto(N*dx,i*dx)

#t1.pencolor("red")

#scr.bgcolor('grey')
#t0.color('white','white')
marg=dx//4
if (0>1):
	t0.goto(x0-marg,y0-marg)
	t0.color('grey','grey')
	t0.pendown()
	t0.begin_fill()
	t0.goto(x0-marg,y0+N*dx+marg)
	t0.goto(x0+N*dx+marg,y0+N*dx+marg)
	t0.goto(x0+N*dx+marg,y0-marg)
	t0.goto(x0-marg,y0-marg)
	t0.end_fill()
t0.penup()
t0.color('black')

t0.color("green","green")
for i in range(0): #N
	for j in range(0): #N
		if (form[0,i,j]==1) and (form[1,i,j]==0):
			t0.penup()
			t0.goto(x0+i*dx,y0+j*dx)
			t0.pendown()
			t0.begin_fill()
			t0.goto(x0+i*dx,y0+(j+1)*dx)
			t0.goto(x0+(i+1)*dx,y0+(j+1)*dx)
			t0.goto(x0+(i+1)*dx,y0+j*dx)
			t0.goto(x0+i*dx,y0+j*dx)
			t0.end_fill()
t0.color("white","white")
#t0.color('grey','grey')
for i in range(N): #N
	for j in range(N): #N
		if (form[0,i,j]==1):
			t0.penup()
			t0.goto(x0-mrg+i*dx,y0-mrg+j*dx)
			t0.pendown()
			t0.begin_fill()
			t0.goto(x0-mrg+i*dx,y0+mrg+(j+1)*dx)
			t0.goto(x0+mrg+(i+1)*dx,y0+mrg+(j+1)*dx)
			t0.goto(x0+mrg+(i+1)*dx,y0-mrg+j*dx)
			t0.goto(x0-mrg+i*dx,y0-mrg+j*dx)
			t0.end_fill()
t0.pencolor("black")
t0.penup()
#t0.goto(0,0)
#t0.pencolor("green")
fdlst=[]
fdn=0
if F>1:
	for i in range(N): #N
		for j in range(N): #N
			if food[i,j]>0:
				fdlst.append(turtle.Turtle())
				fdlst[fdn].shape("cheese.gif")
				fdlst[fdn].resizemode("user")
				fdlst[fdn].shapesize(stretch_wid=food[i,j]/(F-1), stretch_len=food[i,j]/(F-1))
				fdlst[fdn].speed(10)
				fdlst[fdn].penup()
				fdlst[fdn].goto(x0+i*dx+dx//2,y0+j*dx+dx//2)
				fdn+=1

            	            #t1.penup()
            	            #t1.goto(i*dx+dx//2,j*dx+dx//2)
            	            #t1.pendown()
            	            #t1.dot(int(food[i,j]/F*dx))

t2 = turtle.Turtle()
t2.penup()
t2.speed(10)
t1 = turtle.Turtle()
t1.speed(0) #10
t1.penup()
t1.shape("mouse_active3.gif")
t2.shape("cat2.gif")
t1.ht()
t2.ht()

def paintborders():
    t0.width(1)
    t0.pencolor("black")
    for i in range(N):
	    for j in range(N):
		    if (form[0,i,j]==1) and (form[1,i,j]==1):
			    t0.penup()
			    if (i==0) or (form[0,i-1,j]==0):
				    t0.penup()
				    t0.goto(x0-mrg+i*dx,y0+j*dx)
				    t0.pendown()
				    t0.goto(x0-mrg+i*dx,y0+(j+1)*dx)
			    if (j==0) or (form[0,i,j-1]==0):
				    t0.penup()
				    t0.goto(x0+i*dx,y0-mrg+j*dx)
				    t0.pendown()
				    t0.goto(x0+(i+1)*dx,y0-mrg+j*dx)
			    if (i==N-1) or (form[0,i+1,j]==0):
				    t0.penup()
				    t0.goto(x0+mrg+(i+1)*dx,y0+j*dx)
				    t0.pendown()
				    t0.goto(x0+mrg+(i+1)*dx,y0+(j+1)*dx)
			    if (j==N-1) or (form[0,i,j+1]==0):
				    t0.penup()
				    t0.goto(x0+i*dx,y0+mrg+(j+1)*dx)
				    t0.pendown()
				    t0.goto(x0+(i+1)*dx,y0+mrg+(j+1)*dx)
    t0.pencolor("green")
    for i in range(N):
	    for j in range(N):
		    if  (form[0,i,j]==1) and (form[1,i,j]==0):
			    t0.penup()
			    if (i==0) or (form[0,i-1,j]==0):
				    t0.penup()
				    t0.goto(x0-mrg+i*dx,y0+j*dx)
				    t0.pendown()
				    t0.goto(x0-mrg+i*dx,y0+(j+1)*dx)
			    if (j==0) or (form[0,i,j-1]==0):
				    t0.penup()
				    t0.goto(x0+i*dx,y0-mrg+j*dx)
				    t0.pendown()
				    t0.goto(x0+(i+1)*dx,y0-mrg+j*dx)
			    if (i==N-1) or (form[0,i+1,j]==0):
				    t0.penup()
				    t0.goto(x0+mrg+(i+1)*dx,y0+j*dx)
				    t0.pendown()
				    t0.goto(x0+mrg+(i+1)*dx,y0+(j+1)*dx)
			    if (j==N-1) or (form[0,i,j+1]==0):
				    t0.penup()
				    t0.goto(x0+i*dx,y0+mrg+(j+1)*dx)
				    t0.pendown()
				    t0.goto(x0+(i+1)*dx,y0+mrg+(j+1)*dx)
    t0.penup()

paintborders()

t0.getscreen().getcanvas().postscript(file='arena'+pref+'.eps')

xtxt=-400
ytxt=415

tz = turtle.Turtle()
#tz.ht()
tz.penup()

tz.goto(xtxt-300,ytxt-50)
tz.pendown()
tz.write("H agent",font=('Arial',50,'normal'))
tz.penup()

tz.color("white")
tz.speed(10)
yz0=y0
xz0=x0+N*dx+50
dxz=3
dyz=3#10

tz.goto(xz0,yz0)
tz.pendown()
tz.goto(xz0,yz0+500)
tz.seth(90)
tz.stamp()
tz.write('v',font=('Arial',20,'normal') )
tz.penup()
tz.goto(xz0,yz0)
tz.pendown()
tz.goto(xz0+500,yz0)
tz.seth(0)
tz.stamp()
tz.write('t',font=('Arial',20,'normal') )
tz.penup()
tz.ht()
tz.goto(xz0,yz0+int( np.log( zposfin[s//N**4,(s%N**4)//N**2] )*dyz))#,s%N**2
tz.pendown()

t1.penup()
t2.penup()
glide=5
t1.speed(glide)
t2.speed(glide)

turrot = turtle.Turtle()
turrot.ht()
turrot.penup()
turrot.speed(10)
turrot.goto(xtxt,ytxt)


steps=2#5001
tail='png'
t0.getscreen().getcanvas().postscript(file='temp.eps')
im=Im.open("temp.eps") #('cat2.gif')
imcon=im.convert("RGB")
imcon.save("temp."+tail)
img = cv2.imread('temp.'+tail)
height, width, layers = img.shape
framesize = (width,height)
if (uvideo==1):
	outfile='output_video_plots_'+pref+'steps'+str(steps)+'.mp4'
	out = cv2.VideoWriter(outfile,cv2.VideoWriter_fourcc(*'mp4v'), 2*glide, framesize) #cv2.VideoWriter_fourcc(*'MP42') 'DIVX'
	#out.write(img)
else:
	glide=0
bardo=5
trebirth=steps+1
tlifes=[]
occ=np.zeros((N,N),int)
vocc=np.zeros((N,N,Na),int)
v_prod_av=np.zeros((5))
vr_prod_av=np.zeros((N**2+1))
q=np.zeros((N,N))
nq=np.zeros((N,N),int)
Tocc=2500
partocc=np.zeros((steps//Tocc,5))
maxwell_d=1
xwall=2
xhalf=0
if (spos[1]>xwall):
	xhalf=1
if (spos[1]<xwall):
	xhalf=-1
rotcl=0
rotacl=0
rot2cl=0
rot2acl=0
Trot=500
rotco=np.zeros((steps//Trot,2),int)
rot2co=np.zeros((steps//Trot,2),int)
rotepoch=0
ycross=0
ycross0=0
ncross=0
rec=np.zeros((steps+1), int)
rec[0]=s
utxt=0
uar=0
t0_rot=0
n_rot=15#41#23#19#12#15#1#0
tshift=714#2431#1179#412#713#46
tstop=910#2670#2700#1343#1512

tshift=0
tstop=steps#-1
n_rot=0

ucl=0
uacl=0
t_rot=np.zeros((3,steps//5),int)
tcs=np.zeros((3,steps//5),int)
tcross=0

if (urecload==1):
	file = open("trot_"+pref+"_steps"+str(steps), "rb")
	trotfin=np.load(file)
	print("trotfin",trotfin)
	file.close
	file = open("rec_"+pref+"_steps"+str(steps), "rb")
	rec=np.load(file)
	file.close
	file = open("tlifes_"+pref+"_steps"+str(steps), "rb")
	lfs=np.load(file)
	file.close
	print("lfs",lfs)
	print("tbirths")
	t=0
	for i in range(len(lfs)):
		print(t)
		t+=lfs[i]+5
	t=0
if (urecload==1):
    s=rec[tshift]
    spos=stopos(s)
    spos0=stopos(s)

t1.ht()
t2.ht()
t1.goto(x0+spos[1]*dx+dx//2,y0+spos[2]*dx+dx//2)
t2.goto(x0+spos[3]*dx+dx//2,y0+spos[4]*dx+dx//2)

tf = turtle.Turtle()
#tf.ht()
tf.penup()
tf.speed(10)
yf0=y0
xf0=x0-80
dxf=1
dyf=int(300/F)#10
tf.shape('cheese-white.gif')
tf.goto(xf0,yf0)
tf.pencolor('green')
tf.width(20)
tf.pendown()
tf.goto(xf0,yf0+int( s//N**4 *dyf))

yar0=yf0+500
yar1=yar0+200
tar = turtle.Turtle()
tar.ht()
tar.pencolor("black")
tar.penup()
tar.speed(10)
tar.goto(xf0,yar0)
#zmax=np.amax(zposfin[10])
for i in range(0):
        for j in range(0):
                if form[0,i,j]>0:
                        t0.color(( 1.,1.,1.-zposfin[10,i*N+j]/zmax ),( 1.,1.,1.-zposfin[10,i*N+j]/zmax ))
                else:
                        t0.color("white","white")
                t0.penup()
                t0.goto(x0+i*dx+marg,y0+j*dx+marg)
                t0.pendown()
                t0.width(1)
                t0.begin_fill()
                t0.goto(x0+i*dx+marg,y0+(j+1)*dx-marg)
                t0.goto(x0+(i+1)*dx-marg,y0+(j+1)*dx-marg)
                t0.goto(x0+(i+1)*dx-marg,y0+j*dx+marg)
                t0.goto(x0+i*dx+marg,y0+j*dx+marg)
                t0.end_fill()

ep=np.zeros((F),int)
t=tshift
distbin=250#200
dhistT=np.zeros(((-tshift+tstop)//distbin,np.amax(dist)+2),int)
t1.st()
#t2.st()
print("s0,s",spos0,spos,rec[tshift:tshift+2])
for t in range(tshift,tstop):
    pa=np.zeros(Na)*1.
    for a in range(Na):
            if ifa(s,a,1)==1:
                   z2=1.
                   ls,ps=nexts(s,a)
                   #print("a",a)
                   #print("s,a,ls,ps",stopos(s),a,ls,ps)
                   for i in range(len(ls)):
                        s2=ls[i]
                        p2=ps[i]
                        #print("s2", stopos(s2))
                        #print(s2//N**4,(s2%N**4)//N**2,s2%N**2)
                        z2*=zposfin[s2//N**4,(s2%N**4)//N**2]**p2	#,s2%N**2
                   #z2=z2**(1./len(ls) )
                   pa[a]=z2#/zpos[s//N**4,(s%N**4)//N**2,s%N**2]**g
    print("t,pa",t,pa)
    zsum=sum(pa)
    if zsum>0:
        pa*=1./zsum
        lnps=-np.log(ps)
        lnps=lnps*ps
        q[spos[1],spos[2]]+=sum(lnps)
        nq[spos[1],spos[2]]+=1
    #print("pa",pa)
    rnz=np.random.rand()
    if rnz>=nz:
        r=np.random.rand()
        for a in range(Na):
            r=r-pa[a]
            if r<0:
                #print("a ",a)
                break
    else:
        ra=int(rnz/nz*sum(w1[ spos[1]*N+spos[2] ]))
        for a in range(Na):
            if ifa(s,a,1)==1:
                ra=ra-1
            if ra<0:
                #print("a ",a)
                break

    r2=np.random.rand()
    ls,ps=nexts(s,a)
    spos0=stopos(s)
    for a2 in range(len(ls)):
               r2-=ps[a2]
               if r2<0:
                   s=ls[a2]
                   break
    if urecload==0:
        rec[t+1]=s
    if urecload==1:
        s=rec[t+1]
    print("t,s",t,stopos(s))
    spos=stopos(s)

    if (spos[0]>spos0[0]) or (t==trebirth):
        tf.pencolor('green')
    else:
        tf.pencolor('white')
    tf.goto(xf0,yf0+int(s//N**4 *dyf) )
    #t1.goto(x0+spos[1]*dx+dx//2,y0+spos[2]*dx+dx//2)
    #t2.goto(x0+spos[3]*dx+dx//2,y0+spos[4]*dx+dx//2)
    for stp in range(glide):
        st=stp+1
        t1.goto(x0+spos0[1]*dx+int((spos[1]-spos0[1])*dx*st/glide*1.)+dx//2,y0+spos0[2]*dx+int((spos[2]-spos0[2])*dx*st/glide*1.)+dx//2)        
        t2.goto(x0+spos0[3]*dx+int((spos[3]-spos0[3])*dx*st/glide*1.)+dx//2,y0+spos0[4]*dx+int((spos[4]-spos0[4])*dx*st/glide*1.)+dx//2)       
        if (st==glide) and (spos[0]==-1):
            t1.shape("mouse_quiet3.gif")
            if (spos0[0]>-1):
                if (trebirth<steps):
                    tlife=t-trebirth
                else:
                    tlife=t
                tlifes.append(tlife)
                trebirth=t+bardo
            if (t==trebirth):
                u=0
                spos[0]=F-1
                #for k in range(10):
                #	spos[1]=int(N*np.random.rand())
                #	spos[2]=int(N*np.random.rand())
                #	if (form[0,spos[1],spos[2]]==1) and (form[1,spos[3],spos[4]]==1):
                #		u=1
                #		break
                if u==0:
                	spos[2]=1
                	spos[1]=N//2
                s=postos(spos)
                t1.goto(x0+spos[1]*dx+dx//2,y0+spos[2]*dx+dx//2)
                t1.shape("mouse_active3.gif")
                xhalf=0
                if (spos[1]>xwall):
	                xhalf=1
                if (spos[1]<xwall):
	                xhalf=-1
                tf.pencolor('white')
                tf.goto(xf0,yf0)
                tf.pencolor('green')
                tf.goto(xf0,yf0+int(s//N**4 *dyf) )

        t0.getscreen().getcanvas().postscript(file="temp.eps")
        im=Im.open("temp.eps")
        imcon=im.convert("RGB")
        imcon.save("temp."+tail)
        img = cv2.imread('temp.'+tail)
        out.write(img)
    if (glide==0):
        if (spos[0]==-1):
            t1.shape("mouse_quiet3.gif")
            if (spos0[0]>-1):
                if (trebirth<steps):
                    tlife=t-trebirth
                else:
                    tlife=t
                tlifes.append(tlife)
                trebirth=t+bardo
            if (t==trebirth):
                u=0
                spos[0]=F-1
                #for k in range(10):
                #	spos[1]=int(N*np.random.rand())
                #	spos[2]=int(N*np.random.rand())
                #	if (form[0,spos[1],spos[2]]==1) and (form[1,spos[3],spos[4]]==1):
                #		u=1
                #		break
                if u==0:
                	spos[2]=1
                	spos[1]=N//2
                s=postos(spos)
                t1.goto(x0+spos[1]*dx+dx//2,y0+spos[2]*dx+dx//2)
                t1.shape("mouse_active3.gif")
                xhalf=0
                if (spos[1]>xwall):
	                xhalf=1
                if (spos[1]<xwall):
	                xhalf=-1
                tf.pencolor('white')
                tf.goto(xf0,yf0)
                tf.pencolor('green')
                tf.goto(xf0,yf0+int(s//N**4 *dyf) )
    if (spos[0]>=0):
        ep[spos[0]]+=1
        dhist[dist[spos[1]*N+spos[2],spos[3]*N+spos[4]]]+=1
        if (t//distbin<steps//distbin):
            dhistT[t//distbin,dist[spos[1]*N+spos[2],spos[3]*N+spos[4]]]+=1

    if (spos0[0]>-1):
            vocc[spos0[1],spos0[2],(spos[1]-spos0[1]+1)*3+(spos[2]-spos0[2]+1)]+=1
            v_prod=(spos[1]-spos0[1])*(spos[3]-spos0[3])+(spos[2]-spos0[2])*(spos[4]-spos0[4])
            if (v_prod!=0):
                v_prod*=1./np.sqrt((spos[1]-spos0[1])**2+(spos[2]-spos0[2])**2)/np.sqrt((spos[3]-spos0[3])**2+(spos[4]-spos0[4])**2)
            v_prod_av[int(2*v_prod)+2]+=1
            vr_prod=(spos[1]-spos0[1])*(spos0[3]-spos0[1])+(spos[2]-spos0[2])*(spos0[4]-spos0[2])
            if (vr_prod!=0):
                vr_prod*=1./np.sqrt((spos[1]-spos0[1])**2+(spos[2]-spos0[2])**2)/np.sqrt((spos0[3]-spos0[1])**2+(spos0[4]-spos0[2])**2)
            vr_prod_av[int(np.arccos(vr_prod)/np.pi*N**2 ) ]+=1
    if not ( (spos[0]==-1)): # and (spos0[0]==-1) ):
        occ[spos[1],spos[2]]+=1
        #tz.goto(xz0+(t+1)*dxz,yz0+np.log( zposfin[s//N**4,(s%N**4)//N**2] )*dyz)#,s%N**2
        #print("v",np.log( zposfin[s//N**4,(s%N**4)//N**2,s%N**2] ))
        if (maxwell_d==1):
            if (spos0[1]==xwall) and (spos0[2]>2):
                print("wall", (spos[1]-xwall)*xhalf)
                if ( (spos[1]-xwall)*xhalf==-1):
                    print("crosswall")
                    xhalf=spos[1]-xwall
                    ycross0=ycross
                    ycross=spos0[2]
                    tcs[0,ncross]=t
                    tcs[1,ncross]=(spos[1]-xwall)
                    tcs[2,ncross]=2*(ycross//4)-1
                    ncross+=1
                    tcross0=tcross
                    tcross=t

                    if ycross0>0:
                        #print("ycross,ycross0",ycorss,ycross0)
                        if (ycross-ycross0)*xhalf>0:
                            rotcl+=1
                            #if rot0==1:
                            rot2cl+=1
                            ucl+=1
                            #rot0=1
                        if (ycross-ycross0)*xhalf<0:
                            rotacl+=1
                            #if rot0==-1:
                            rot2acl+=1
                            uacl+=1
                            #rot0=-1
                        print("ucl,uacl",ucl,uacl)
                        if (ycross-ycross0)==0:
                            #rot0=0
                            rot2cl=(rot2cl//2)*2
                            rota2cl=(rot2acl//2)*2
                            if ucl>0:
                                if urecload==0:
                                    t_rot[0,n_rot]=t0_rot
                                    t_rot[1,n_rot]=tcross0
                                    t_rot[2,n_rot]=ucl
                                n_rot+=1
                            if uacl>0:
                                if urecload==0:
                                    t_rot[0,n_rot]=t0_rot
                                    t_rot[1,n_rot]=tcross0
                                    t_rot[2,n_rot]=-uacl
                                n_rot+=1
                            t0_rot=t
                            ucl=0
                            uacl=0
                        print("!!!!!!!")
                        print("rot2cl,rot2acl",rot2cl,rot2acl)
                        print("n_rot,t_rot",n_rot,t_rot[:,0:n_rot+1])
                    else:
                        t0_rot=t


                    if (urecload==1):
                        print("n_rot, trotfin, t0, tcross0, ucl, uacl",n_rot,trotfin[:,n_rot],t0_rot,tcross0,ucl,uacl) #, utxt, urecload)
                        if (t>=trotfin[0,n_rot]) and (t<trotfin[1,n_rot]):
                            print("rot_start",trotfin[2,n_rot],trotfin[2,n_rot]>1,trotfin[2,n_rot]<-1)
                            print("xhalf,uar",xhalf,uar)
                            if  (xhalf<0) and (uar==0):
                                if ycross>4:
                                    print("updown")
                                    tar.penup()
                                    tar.goto(xf0,yar1)
                                    tar.pendown()
                                    tar.goto(xf0,yar0)
                                    tar.seth(270)
                                    tar.stamp()
                                    tar.penup()
                                    uar=1
                                else:
                                    if ycross>0:
                                        print("downup")
                                        tar.penup()
                                        tar.goto(xf0,yar0)
                                        tar.pendown()
                                        tar.goto(xf0,yar1)
                                        tar.seth(90)
                                        tar.stamp()
                                        tar.penup()
                                        uar=1
                            if  (xhalf>0):
                                tar.clear()
                                uar=0
                            print("utxt",utxt)
                            if (utxt==0):
                                if trotfin[2,n_rot]>1:
                                    print("clockwise rotation")
                                    turrot.clear()
                                    turrot.goto(xtxt,ytxt)
                                    turrot.pendown()
                                    turrot.write("clockwise rotation",font=('Arial',20,'normal'))
                                    turrot.penup()
                                    utxt=1
                                if trotfin[2,n_rot]<-1:
                                    print("anticlockwise rotation")
                                    turrot.clear()
                                    turrot.goto(xtxt,ytxt)
                                    turrot.pendown()
                                    turrot.write("anticlockwise rotation",font=('Arial',20,'normal'))
                                    turrot.penup()
                                    utxt=1
                        if t==trotfin[1,n_rot]:
                            print("rot_stop")
                            turrot.clear()
                            utxt=0
                            tar.clear()
                            uar=0



                if (xhalf==0):
                    xhalf=spos[1]-xwall
    else:
        tz.goto(xz0+(t+1)*dxz,yz0-dyz)
        if (spos0[0]>-1):
                        rot2cl=(rot2cl//2)*2
                        rota2cl=(rot2acl//2)*2
                        if ucl>0:
                            if urecload==0:
                                t_rot[0,n_rot]=t0_rot
                                t_rot[1,n_rot]=tcross
                                t_rot[2,n_rot]=ucl
                            n_rot+=1
                        if uacl>0:
                            if urecload==0:
                                t_rot[0,n_rot]=t0_rot
                                t_rot[1,n_rot]=tcross
                                t_rot[2,n_rot]=-uacl
                            n_rot+=1
                        t0_rot=t
                        print("ucl,uacl,n_rot,t_rot",ucl,uacl,n_rot,t_rot[:,0:n_rot+1])
                        ycross0=0
                        ycross=0
                        xhalf=0
                        ucl=0
                        uacl=0
                        print("rot_stop")
                        turrot.clear()
                        utxt=0
                        tar.clear()
                        uar=0

    if (t%Trot==0) and (t>0):
        rotco[rotepoch,0]=rotcl
        rotco[rotepoch,1]=rotacl
        rotcl=0
        rotacl=0
        rot2co[rotepoch,0]=rot2cl//2
        rot2co[rotepoch,1]=rot2acl//2
        rot2cl-=rot2cl//2
        rot2acl-=rot2acl//2
        rotepoch+=1
    if (t%Tocc==0) and (t>0):
        stocc=t//Tocc-1
        partocc[stocc,0]=np.sum(occ[0:3,:])
        partocc[stocc,1]=np.sum(occ[3:N//2,:])
        partocc[stocc,2]=np.sum(occ[N//2,:])
        partocc[stocc,3]=np.sum(occ[N//2+1:N-3,:])
        partocc[stocc,4]=np.sum(occ[N-3:N,:])
        #if (t>Tocc):
        #    partocc[stocc,:]+=-partocc[stocc-1,:]

if ucl>0:
    t_rot[0,n_rot]=t0_rot
    t_rot[1,n_rot]=t
    t_rot[2,n_rot]=ucl
    n_rot+=1
if uacl>0:
    t_rot[0,n_rot]=t0_rot
    t_rot[1,n_rot]=t
    t_rot[2,n_rot]=-uacl
    n_rot+=1

if (urecload==0):
	trotfin=np.zeros((3,n_rot),int)
	trotfin=t_rot[:,0:n_rot]
	file = open("trot_"+pref+"_steps"+str(steps), "wb")
	np.save(file, trotfin)
	file.close
	file = open("rec_"+pref+"_steps"+str(steps), "wb")
	np.save(file, rec)
	file.close


print("dhist",dhist)
file = open("dhist_"+pref+"_steps"+str(steps), "wb")
np.save(file, dhist)
file.close
print("dhistT",dhistT)
file = open("dhistT_"+pref+"_steps"+str(steps)+"distbin"+str(distbin), "wb")
np.save(file, dhistT)
file.close
#rot2cl=(rot2cl//2)
#rota2cl=(rot2acl//2)
print("occ",occ)
print("tlifes",tlifes)
file = open("tlifes_"+pref+"_steps"+str(steps), "wb")
np.save(file, tlifes)
file.close
if (len(tlifes)>0):
	print("t_av",sum(tlifes) / len(tlifes))
print("v_prod",v_prod_av)
v_prod_av*=1./sum(v_prod_av)
print("v_prod_av",v_prod_av)
print("vr_prod",vr_prod_av)
print("ep",ep)
print("ep_norm",ep*1./sum(ep))
if (maxwell_d==1):
	print("rotcl,rotacl,rot2cl,rot2acl,ncross",rotcl,rotacl,rot2cl,rot2acl,ncross)
	print("rotco",rotco)
	file = open("rotco_"+pref+"_steps"+str(steps), "wb")
	np.save(file, rotco)
	file.close
	file = open("rot2co_"+pref+"_steps"+str(steps), "wb")
	np.save(file, rot2co)
	file.close
if (uvideo==1):
	out.release()


parTocc=np.zeros((steps//Tocc,5))
parTocc[0]=partocc[0]
for i in range(1,steps//Tocc):
    parTocc[i]=partocc[i]-partocc[i-1]
print("parTocc",parTocc)
#print("partocc",partocc)
file = open("parTocc_"+pref+"_steps"+str(steps)+"Tocc"+str(Tocc), "wb")
np.save(file, parTocc)
file.close

parocc=np.zeros((5))
#for i in range(5):
#    parocc=sum(partocc[:,i])
#parocc[0]=sum(sum(occ[0:3,:]))
#parocc[1]=sum(sum(occ[3:5,:]))
#parocc[2]=sum(occ[5,:])
#parocc[3]=sum(sum(occ[6:8,:]))
#parocc[4]=sum(sum(occ[8:11,:]))
parocc[0]=np.sum(occ[0:3,:])
parocc[1]=np.sum(occ[3:N//2,:])
parocc[2]=np.sum(occ[N//2,:])
parocc[3]=np.sum(occ[N//2+1:N-3,:])
parocc[4]=np.sum(occ[N-3:N,:])
print("parocc",parocc)

print("occ",occ)
file = open("occ_"+pref+"steps"+str(steps), "wb")
np.save(file, occ)
file.close

t1.ht()
t2.ht()
tz.clear()
tf.clear()
tf.ht()
for i in range(len(fdlst)):
	fdlst[i].ht()
dx_vocc=dx//2
marg=0

parr=np.zeros((2,4), int)
parr[0]=np.array([int(0.4*F),int(0.4*F),int(0.8*F),int(0.8*F)])
parr[1]=np.array([2*N+3,5*N+4,2*N+3,5*N+4])
print("parr",parr)
z_vocc=np.zeros((N,N,Na))
for k in range(0):#4
    t0.clear()
    cut=zposfin[parr[0,k],:,parr[1,k]]
    cut.shape = (cut.size//N, N)
    maxcut=np.amax(cut)#np.amax(zposfin)
    for i in range(N):
        for j in range(N):
            if form[0,i,j]==1:
                if cut[i,j]>0:
                        vxsum=0.
                        vysum=0.
                        t0.color(( 1.,1.,1.-cut[i,j]/maxcut ),( 1.,1.,1.-cut[i,j]/maxcut ))
                else:
                        t0.color("white","white")

                t0.width(1)
                t0.penup()
                t0.goto(x0+i*dx+marg,y0+j*dx+marg)
                t0.pendown()
                t0.width(1)
                t0.begin_fill()
                t0.goto(x0+i*dx+marg,y0+(j+1)*dx-marg)
                t0.goto(x0+(i+1)*dx-marg,y0+(j+1)*dx-marg)
                t0.goto(x0+(i+1)*dx-marg,y0+j*dx+marg)
                t0.goto(x0+i*dx+marg,y0+j*dx+marg)
                t0.end_fill()
                t0.pencolor("black")
                s=postos(np.array([parr[0,k],i,j,parr[1,k]//N,parr[1,k]%N]))
                if not (i*N+j==parr[1,k]):
                    pa=np.zeros(Na)*1.
                    for a in range(Na):
                            if ifa(s,a,1)==1:
                                   z2=1.
                                   ls,ps=nexts(s,a)
                                   #print("a",a)
                                   #print("s,a,ls,ps",stopos(s),a,ls,ps)
                                   for l in range(len(ls)):
                                        s2=ls[l]
                                        p2=ps[l]
                                        #print("s2", stopos(s2))
                                        #print(s2//N**4,(s2%N**4)//N**2,s2%N**2)
                                        z2*=zposfin[s2//N**4,(s2%N**4)//N**2,s2%N**2]**p2	
                                   pa[a]=z2#/zpos[s//N**4,(s%N**4)//N**2,s%N**2]**g
                    zsum=sum(pa)
                    if zsum>0:
                        pa*=1./zsum
                    #print("i,j,pa",i,j,pa)
                    for a in range(Na):
                            va=pa[a]
                            z_vocc[i,j,a]=va
                            if (va>0):
                                t0.penup()
                                t0.goto(x0+i*dx+dx//2,y0+j*dx+dx//2)
                                t0.pendown()
                                if (a==4):
                                    t0.width(2)
                                    t0.goto(x0+i*dx+dx//2,y0+j*dx+dx//2-int(va*dx_vocc/2))
                                    t0.circle(int(va*dx_vocc/2))
                                else:
                                    t0.width(3)
                                    t0.goto(x0+i*dx+dx//2+(a//3-1)*int(va*dx_vocc),y0+j*dx+dx//2+(a%3-1)*int(va*dx_vocc))
    paintborders()
    t0.penup()
    t0.getscreen().getcanvas().postscript(file="z_v_"+str(k)+"_"+pref+".eps")
    file = open("zcut_"+"E"+str(parr[0,k])+"cat"+str(parr[1,k]//N)+"_"+str(parr[1,k]%N)+"_"+pref, "wb")
    np.save(file, cut)
    file.close
    file = open("zcut_vocc_"+"E"+str(parr[0,k])+"cat"+str(parr[1,k]//N)+"_"+str(parr[1,k]%N)+"_"+pref, "wb")
    np.save(file, z_vocc)
    file.close

maxocc=np.amax(occ)
vah=np.zeros((N,N))
vocc_norm=np.zeros((N,N,Na))
vocc_norm_av=np.zeros((N,N,2))
vav=0
vu=0
t0.clear()
for i in range(N):
        for j in range(N):
            if form[0,i,j]==1:
                if occ[i,j]>0:
                        vxsum=0.
                        vysum=0.
                        #t0.penup()
                        #t0.goto(x0+i*dx+dx//2,y0+j*dx+dx//2)
                        #t0.pendown()
                        #t0.pencolor(( occ[i,j]/maxocc/2,occ[i,j]/maxocc/2,1.-occ[i,j]/maxocc ))
                        #t0.pencolor(( 1.,1.,1.-occ[i,j]/maxocc ))
                        #t0.dot(int(dx*0.75)) #int(occ[i,j]/maxocc*dx))
                        t0.color(( 1.,1.,1.-occ[i,j]/maxocc ),( 1.,1.,1.-occ[i,j]/maxocc ))
                else:
                        t0.color("white","white")

                t0.width(1)
                t0.penup()
                t0.goto(x0+i*dx+marg,y0+j*dx+marg)
                t0.pendown()
                t0.width(1)
                t0.begin_fill()
                t0.goto(x0+i*dx+marg,y0+(j+1)*dx-marg)
                t0.goto(x0+(i+1)*dx-marg,y0+(j+1)*dx-marg)
                t0.goto(x0+(i+1)*dx-marg,y0+j*dx+marg)
                t0.goto(x0+i*dx+marg,y0+j*dx+marg)
                t0.end_fill()
                t0.pencolor("black")
                if (occ[i,j]>0) and (vu==1):
                    for a in range(Na):
                            va=vocc[i,j,a]*1./(sum(vocc[i,j,:]))
                            vocc_norm[i,j,a]=va
                            if va>0:
                                    vah[i,j]+=-va*np.log(va)
                            vxsum+=va*(a//3-1)
                            vysum+=va*(a%3-1)
                            if (vocc[i,j,a]>0) and (vav!=1):
                                t0.penup()
                                t0.goto(x0+i*dx+dx//2,y0+j*dx+dx//2)
                                t0.pendown()
                                if (a==4):
                                    t0.width(2)
                                    t0.goto(x0+i*dx+dx//2,y0+j*dx+dx//2-int(va*dx_vocc/2))
                                    t0.circle(int(va*dx_vocc/2))
                                else:
                                    t0.width(3)
                                    t0.goto(x0+i*dx+dx//2+(a//3-1)*int(va*dx_vocc),y0+j*dx+dx//2+(a%3-1)*int(va*dx_vocc))
                    vocc_norm_av[i,j,0]=vxsum
                    vocc_norm_av[i,j,1]=vysum
                    if vav==1:
                            t0.penup()
                            t0.goto(x0+i*dx+dx//2,y0+j*dx+dx//2)
                            t0.pendown()
                            t0.width(3)
                            t0.goto(x0+i*dx+dx//2+(a//3-1)*int(vxsum*dx_vocc),y0+j*dx+dx//2+(a%3-1)*int(vysum*dx_vocc))

paintborders()
t0.penup()
t0.getscreen().getcanvas().postscript(file="occ_vocc_vav"+str(vav)+"_"+pref+".eps")
file = open("vocc_norm_"+pref+"steps"+str(steps), "wb")
np.save(file, vocc_norm)
file.close
file = open("vocc_norm_av_"+pref+"steps"+str(steps), "wb")
np.save(file, vocc_norm_av)
file.close

maxvah=np.amax(vah)
print("vah",vah)
print("maxvah",maxvah)
t0.clear()
t0.width(1)
for i in range(N):
        for j in range(N):
                if vah[i,j]>0:
                        t0.color(( 1.,1.,1.-vah[i,j]/maxvah ),( 1.,1.,1.-vah[i,j]/maxvah ))
                else:
                        t0.color("white","white")
                t0.penup()
                t0.goto(x0+i*dx+marg,y0+j*dx+marg)
                t0.pendown()
                t0.width(1)
                t0.begin_fill()
                t0.goto(x0+i*dx+marg,y0+(j+1)*dx-marg)
                t0.goto(x0+(i+1)*dx-marg,y0+(j+1)*dx-marg)
                t0.goto(x0+(i+1)*dx-marg,y0+j*dx+marg)
                t0.goto(x0+i*dx+marg,y0+j*dx+marg)
                t0.end_fill()
t0.pencolor("black")
paintborders()
t0.getscreen().getcanvas().postscript(file="vah_"+pref+".eps")

print("q",q)
print("nq",nq)
for i in range(N):
         for j in range(N):
                if nq[i,j]>0:
                        q[i,j]=q[i,j]/nq[i,j]
qmax=np.amax(q)
t0.clear()
t0.width(1)
for i in range(N):
        for j in range(N):
                if nq[i,j]>0:
                        t0.color(( 1.,1.,1.-q[i,j]/qmax ),( 1.,1.,1.-q[i,j]/qmax ))
                else:
                        t0.color("white","white")
                t0.penup()
                t0.goto(x0+i*dx+marg,y0+j*dx+marg)
                t0.pendown()
                t0.width(1)
                t0.begin_fill()
                t0.goto(x0+i*dx+marg,y0+(j+1)*dx-marg)
                t0.goto(x0+(i+1)*dx-marg,y0+(j+1)*dx-marg)
                t0.goto(x0+(i+1)*dx-marg,y0+j*dx+marg)
                t0.goto(x0+i*dx+marg,y0+j*dx+marg)
                t0.end_fill()
t0.pencolor("black")
paintborders()
t0.getscreen().getcanvas().postscript(file="q_"+pref+".eps")

t0.clear()
t0.width(1)
t0.penup()
t0.color("black","black")
t0.goto(xz0,yz0)
t0.pendown()
t0.goto(xz0,yz0+500)
t0.seth(90)
t0.stamp()
t0.write('p',font=('Arial',20,'normal') )
t0.penup()
t0.goto(xz0,yz0)
t0.pendown()
t0.goto(xz0+500,yz0)
t0.seth(0)
t0.stamp()
t0.write('E',font=('Arial',20,'normal') )
t0.goto(xz0,yz0)
t0.pendown()
epav=ep*1./sum(ep)
file = open("ep_"+pref, "wb")
np.save(file, epav)
file.close
i=0
for pe in epav:
	t0.goto(xz0+i*30,yz0+int(pe*5000))
	i+=1
t0.penup()
file = open("ep_"+"dp2_zformedcommonW_mouselab_bottleneck_fulltank "+postf, "rb")
epav2 = np.load(file)
file.close
print("epav2",epav2)
i=0
t0.penup()
t0.pencolor("grey")
t0.goto(xz0,yz0)
t0.pendown()
for pe in epav2:
	t0.goto(xz0+i*30,yz0+int(pe*5000))
	i+=1
t0.getscreen().getcanvas().postscript(file="pe_"+pref+".eps")